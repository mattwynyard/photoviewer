[{"S:\\website\\photoviewer\\client\\src\\index.js":"1","S:\\website\\photoviewer\\client\\src\\Main.js":"2","S:\\website\\photoviewer\\client\\src\\serviceWorker.js":"3","S:\\website\\photoviewer\\client\\src\\Data.js":"4","S:\\website\\photoviewer\\client\\src\\Report.js":"5","S:\\website\\photoviewer\\client\\src\\App.js":"6","S:\\website\\photoviewer\\client\\src\\CustomNav.js":"7","S:\\website\\photoviewer\\client\\src\\DynamicDropdown.js":"8","S:\\website\\photoviewer\\client\\src\\CustomModal.js":"9","S:\\website\\photoviewer\\client\\src\\Drawer.js":"10","S:\\website\\photoviewer\\client\\src\\ToolsMenu.js":"11","S:\\website\\photoviewer\\client\\src\\VideoCard.js":"12","S:\\website\\photoviewer\\client\\src\\PhotoModal.js":"13","S:\\website\\photoviewer\\client\\src\\ArchivePhotoModal.js":"14","S:\\website\\photoviewer\\client\\src\\GLEngine.js":"15","S:\\website\\photoviewer\\client\\src\\util.js":"16","S:\\website\\photoviewer\\client\\src\\PositionControl.js":"17","S:\\website\\photoviewer\\client\\src\\MediaPlayerControl.js":"18","S:\\website\\photoviewer\\client\\src\\L.CanvasOverlay.js":"19","S:\\website\\photoviewer\\client\\src\\Vector2D.js":"20"},{"size":603,"mtime":1601929236389,"results":"21","hashOfConfig":"22"},{"size":609,"mtime":1613679015859,"results":"23","hashOfConfig":"22"},{"size":5086,"mtime":1589839304022,"results":"24","hashOfConfig":"22"},{"size":2678,"mtime":1613698966687,"results":"25","hashOfConfig":"22"},{"size":18140,"mtime":1611276860708,"results":"26","hashOfConfig":"22"},{"size":96061,"mtime":1624930532310,"results":"27","hashOfConfig":"22"},{"size":1267,"mtime":1601929236331,"results":"28","hashOfConfig":"22"},{"size":1243,"mtime":1591046122069,"results":"29","hashOfConfig":"22"},{"size":20944,"mtime":1601929236295,"results":"30","hashOfConfig":"22"},{"size":2820,"mtime":1611868991748,"results":"31","hashOfConfig":"22"},{"size":1157,"mtime":1611691845441,"results":"32","hashOfConfig":"22"},{"size":10067,"mtime":1615161894723,"results":"33","hashOfConfig":"22"},{"size":10386,"mtime":1605486409407,"results":"34","hashOfConfig":"22"},{"size":5731,"mtime":1606267300960,"results":"35","hashOfConfig":"22"},{"size":28257,"mtime":1624933861520,"results":"36","hashOfConfig":"22"},{"size":3981,"mtime":1624411134245,"results":"37","hashOfConfig":"22"},{"size":600,"mtime":1589839303659,"results":"38","hashOfConfig":"22"},{"size":604,"mtime":1607034864202,"results":"39","hashOfConfig":"22"},{"size":4786,"mtime":1624926015963,"results":"40","hashOfConfig":"22"},{"size":2757,"mtime":1589839303674,"results":"41","hashOfConfig":"22"},{"filePath":"42","messages":"43","errorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":"44"},"1ps959",{"filePath":"45","messages":"46","errorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":"44"},{"filePath":"47","messages":"48","errorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":"44"},{"filePath":"49","messages":"50","errorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":"44"},{"filePath":"51","messages":"52","errorCount":0,"warningCount":13,"fixableErrorCount":0,"fixableWarningCount":0,"source":"53","usedDeprecatedRules":"44"},{"filePath":"54","messages":"55","errorCount":0,"warningCount":7,"fixableErrorCount":0,"fixableWarningCount":0,"source":null},{"filePath":"56","messages":"57","errorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":"44"},{"filePath":"58","messages":"59","errorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":"44"},{"filePath":"60","messages":"61","errorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":"44"},{"filePath":"62","messages":"63","errorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":"44"},{"filePath":"64","messages":"65","errorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":"44"},{"filePath":"66","messages":"67","errorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":"44"},{"filePath":"68","messages":"69","errorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":"44"},{"filePath":"70","messages":"71","errorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":"44"},{"filePath":"72","messages":"73","errorCount":0,"warningCount":9,"fixableErrorCount":0,"fixableWarningCount":0,"source":"74"},{"filePath":"75","messages":"76","errorCount":0,"warningCount":1,"fixableErrorCount":0,"fixableWarningCount":0,"source":"77","usedDeprecatedRules":"44"},{"filePath":"78","messages":"79","errorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":"44"},{"filePath":"80","messages":"81","errorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":"44"},{"filePath":"82","messages":"83","errorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":"44"},{"filePath":"84","messages":"85","errorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":"44"},"S:\\website\\photoviewer\\client\\src\\index.js",[],["86","87"],"S:\\website\\photoviewer\\client\\src\\Main.js",[],"S:\\website\\photoviewer\\client\\src\\serviceWorker.js",[],"S:\\website\\photoviewer\\client\\src\\Data.js",[],"S:\\website\\photoviewer\\client\\src\\Report.js",["88","89","90","91","92","93","94","95","96","97","98","99","100"],"import React from 'react';\r\nimport './Report.css';\r\nimport './CustomNav.js';\r\nimport { Link } from \"react-router-dom\";\r\nimport {Navbar, Nav}  from 'react-bootstrap';\r\nimport CustomNav from './CustomNav.js';\r\nimport Chart from 'chart.js';\r\n\r\nconst NO_COLORS = 9;\r\n\r\nclass Report extends React.Component {\r\n\r\n    constructor(props) {\r\n        super(props);\r\n        this.state = {\r\n            mode: props.location.project.surface,\r\n        }\r\n        \r\n    }\r\n\r\n    addMap(map, data) {\r\n        if (map.has(data)) {\r\n            let n = map.get(data);\r\n            n = n + 1;\r\n            map.set(data, n); \r\n        } else {\r\n            if (data !== 0) {\r\n                map.set(data, 1); \r\n            }   \r\n        }\r\n        return map;\r\n    }\r\n\r\n    buildColorTable(count) {\r\n        let arr = [];\r\n        for(let i = 0; i < count; i++) {\r\n            arr.push(this.colorMap[i]);\r\n        }\r\n        return arr;\r\n    }\r\n\r\n    clickChart(e) {\r\n        console.log(this.gradeChart.getElementsAtEvent(e));\r\n    }\r\n\r\n    componentDidMount() {\r\n\r\n        this.colorMap = [\r\n            \"#FFC857\", \"#058ED9\", \"#BDD9BF\", \"#E8F086\", \"#6FDE6E\", \"#FF4242\", \"#A691AE\", \"#235FA4\", \"#0A284B\", \"#848FA2\"\r\n        ];\r\n        \r\n        if(this.state.mode === \"footpath\") {\r\n            this.gradeMap = new Map();\r\n            this.faultMap = new Map();\r\n            this.causeMap = new Map();\r\n            this.surfaceMap = new Map();\r\n            this.data.forEach(item => {\r\n                this.faultMap = this.addMap(this.faultMap, item.fault);\r\n                this.causeMap = this.addMap(this.causeMap, item.cause);\r\n                this.surfaceMap = this.addMap(this.surfaceMap, item.fpsurface);\r\n                this.gradeMap = this.addMap(this.gradeMap, item.grade);\r\n            });\r\n\r\n            let gradeData = Array.from(this.gradeMap, ([name, value]) => ({ name, value }));\r\n            //let faultData = Array.from(this.faultMap, ([name, value]) => ({ name, value }));\r\n            let faultData = Array.from(this.faultMap, ([name, value]) => ({ name, value }));\r\n            let causeData = Array.from(this.causeMap, ([name, value]) => ({ name, value }));\r\n            let surfaceData = Array.from(this.surfaceMap, ([name, value]) => ({ name, value }));\r\n            gradeData.sort((a, b) => (a.value < b.value) ? 1 : -1);\r\n            //faultData.sort((a, b) => (a.value < b.value) ? 1 : -1);\r\n            faultData.sort((a, b) => (a.value < b.value) ? 1 : -1);\r\n            causeData.sort((a, b) => (a.value < b.value) ? 1 : -1);\r\n            surfaceData.sort((a, b) => (a.value < b.value) ? 1 : -1);\r\n            let faultTop = faultData.slice(0, NO_COLORS);\r\n            let faultBottom = faultData.slice(NO_COLORS, faultData.length);\r\n            let causeTop = causeData.slice(0, NO_COLORS);\r\n            let causeBottom = causeData.slice( NO_COLORS, causeData.length);\r\n            let surfaceTop = surfaceData.slice(0, NO_COLORS);\r\n            let surfaceBottom = surfaceData.slice(NO_COLORS, surfaceData.length);\r\n            let value1 = 0;\r\n            let value2 = 0;\r\n            let value3 = 0;\r\n            faultBottom.forEach(item => {\r\n                value1 += item.value;\r\n            });\r\n            causeBottom.forEach(item => {\r\n                value2 += item.value;\r\n            });\r\n            surfaceBottom.forEach(item => {\r\n                value3 += item.value;\r\n            });\r\n            let others1 = {name: \"Others\", value: value1};\r\n            let others2 = {name: \"Others\", value: value2};\r\n            let others3 = {name: \"Others\", value: value3};\r\n            faultTop.push(others1);\r\n            causeTop.push(others2);\r\n            surfaceTop.push(others3);\r\n           \r\n            var ctx = document.getElementById('myChart').getContext(\"2d\");\r\n            this.gradeChart = new Chart(ctx, {\r\n                type: 'doughnut',\r\n                data: {\r\n                    labels: gradeData.map((gradeData) => gradeData.name + \": \" + gradeData.value),\r\n                    datasets: [{\r\n                        data: gradeData.map((gradeData) => gradeData.value),\r\n                        backgroundColor: [\r\n                            'rgba(0, 204, 0, 1)',\r\n                            'rgba(255, 128, 0, 1)',\r\n                            'rgba(255, 0, 255, 1)',\r\n                            'rgba(0, 0, 255, 1)',\r\n                        ],\r\n                        borderColor: [\r\n                            'rgba(0, 204, 0, 1)',\r\n                            'rgba(255, 128, 0, 1)',\r\n                            'rgba(255, 0, 255, 1)',\r\n                            'rgba(0, 0, 255, 1)',    \r\n                        ],\r\n                        borderWidth: 1\r\n                    }]\r\n                },\r\n                options: {\r\n                    onClick: (e) => {\r\n                        this.clickChart(e);\r\n                    },\r\n                    title: {\r\n                        display: true,\r\n                        position: 'top',\r\n                        text: 'Grade',\r\n                    },\r\n                    maintainAspectRatio: false,\r\n                    responsive: true,\r\n                    legend: {\r\n                        position: 'right',\r\n                        fullWidth: false,\r\n                        labels: {\r\n                            padding: 10,\r\n                            boxWidth: 12\r\n                        }\r\n                    }\r\n                }\r\n            });\r\n    \r\n            var ctx = document.getElementById(\"grade1\").getContext('2d');\r\n            this.g1Chart = new Chart(ctx, {\r\n                type: 'doughnut',\r\n                data: {\r\n                    labels: faultTop.map((faultTop) => faultTop.name + \": \" + faultTop.value),\r\n                    datasets: [{\r\n                        data: faultTop.map((faultTop) => faultTop.value),\r\n                        backgroundColor: this.buildColorTable(faultTop.length),\r\n                        borderColor: this.buildColorTable(faultTop.length),\r\n                        borderWidth: 1\r\n                    }]\r\n                },\r\n                options: {\r\n                    title: {\r\n                        display: true,\r\n                        position: 'top',\r\n                        text: 'Fault Type',\r\n                    },\r\n                    maintainAspectRatio: false,\r\n                    responsive: true,\r\n                    legend: {\r\n                        position: 'right',\r\n                        fullWidth: false,\r\n                        labels: {\r\n                            padding: 10,\r\n                            boxWidth: 12\r\n                        }\r\n                    }\r\n                }\r\n            });\r\n    \r\n            var ctx = document.getElementById(\"grade2\").getContext('2d');\r\n            var g2Chart = new Chart(ctx, {\r\n                type: 'doughnut',\r\n            data: {\r\n                labels: causeTop.map((causeTop) => causeTop.name + \": \" + causeTop.value),\r\n                datasets: [{\r\n                    data: causeTop.map((causeTop) => causeTop.value),\r\n                    backgroundColor: this.buildColorTable(causeTop.length),\r\n                    borderColor: this.buildColorTable(causeTop.length),\r\n                    borderWidth: 1\r\n                }]\r\n            },\r\n            options: {\r\n                title: {\r\n                    display: true,\r\n                    text: 'Cause',\r\n                },\r\n                maintainAspectRatio: false,\r\n                responsive: true,\r\n                legend: {\r\n                    position: 'right',\r\n                    labels: {\r\n                        padding: 10,\r\n                        boxWidth: 12\r\n                    }\r\n                }\r\n            }\r\n            });\r\n    \r\n            var ctx = document.getElementById(\"grade3\").getContext('2d');\r\n                var g3Chart = new Chart(ctx, {\r\n                    type: 'doughnut',\r\n                data: {\r\n                    labels: surfaceTop.map((surfaceTop) => surfaceTop.name + \": \" + surfaceTop.value),\r\n                    datasets: [{\r\n                        data: surfaceTop.map((surfaceTop) => surfaceTop.value),\r\n                        backgroundColor: this.buildColorTable(surfaceTop.length),\r\n                        borderColor: this.buildColorTable(surfaceTop.length),\r\n                        borderWidth: 1\r\n                    }]\r\n                },\r\n                options: {\r\n                    title: {\r\n                        display: true,\r\n                        text: 'Surface',\r\n                        padding: 5,\r\n                    },\r\n                    maintainAspectRatio: false,\r\n                    responsive: true,\r\n                    legend: {\r\n                        position: 'right',\r\n                        labels: {\r\n                            padding: 10,\r\n                            boxWidth: 12\r\n                        }\r\n                    }\r\n                }\r\n                });\r\n            \r\n        } else {\r\n            this.gradeMap = new Map();\r\n            this.g1Map = new Map();\r\n            this.g2Map = new Map();\r\n            this.g3Map = new Map();\r\n            this.data.forEach(item => {\r\n                if (item.priority !== 0 ) {\r\n                    if (item.priority === 99) {\r\n                        item.priority = \"Signage\";\r\n                    } else {\r\n                        item.priority = \"Priority: \" + item.priority;\r\n                    }\r\n                }\r\n                switch(item.priority) {\r\n                    case  \"Priority: 1\":\r\n                        this.g1Map = this.addMap(this.g1Map, item.fault);\r\n                        break;\r\n                    case  \"Priority: 2\":\r\n                        this.g2Map = this.addMap(this.g2Map, item.fault);\r\n                        break;\r\n                    case  \"Priority: 3\":\r\n                        this.g3Map = this.addMap(this.g3Map, item.fault);\r\n                        break;\r\n                    default:\r\n                        break;\r\n\r\n                }\r\n                this.gradeMap = this.addMap(this.gradeMap, item.priority);\r\n                //this.faultMap = this.addMap(this.faultMap, item.class);\r\n            });\r\n\r\n            let gradeData = Array.from(this.gradeMap, ([name, value]) => ({ name, value }));\r\n        //let faultData = Array.from(this.faultMap, ([name, value]) => ({ name, value }));\r\n        let g1Data = Array.from(this.g1Map, ([name, value]) => ({ name, value }));\r\n        let g2Data = Array.from(this.g2Map, ([name, value]) => ({ name, value }));\r\n        let g3Data = Array.from(this.g3Map, ([name, value]) => ({ name, value }));\r\n        gradeData.sort((a, b) => (a.value < b.value) ? 1 : -1);\r\n        //faultData.sort((a, b) => (a.value < b.value) ? 1 : -1);\r\n        g1Data.sort((a, b) => (a.value < b.value) ? 1 : -1);\r\n        g2Data.sort((a, b) => (a.value < b.value) ? 1 : -1);\r\n        g3Data.sort((a, b) => (a.value < b.value) ? 1 : -1);\r\n        let g1Top = g1Data.slice(0, NO_COLORS);\r\n        let g1Bottom = g1Data.slice(NO_COLORS, g1Data.length);\r\n        let g2Top = g2Data.slice(0, NO_COLORS);\r\n        let g2Bottom = g2Data.slice(NO_COLORS, g2Data.length);\r\n        let g3Top = g3Data.slice(0, NO_COLORS);\r\n        let g3Bottom = g3Data.slice(NO_COLORS, g3Data.length);\r\n        let value1 = 0;\r\n        let value2 = 0;\r\n        let value3 = 0;\r\n        g1Bottom.forEach(item => {\r\n            value1 += item.value;\r\n        });\r\n        g2Bottom.forEach(item => {\r\n            value2 += item.value;\r\n        });\r\n        g3Bottom.forEach(item => {\r\n            value3 += item.value;\r\n        });\r\n        let others1 = {name: \"Others\", value: value1};\r\n        let others2 = {name: \"Others\", value: value2};\r\n        let others3 = {name: \"Others\", value: value3};\r\n        g1Top.push(others1);\r\n        g2Top.push(others2);\r\n        g3Top.push(others3);\r\n       \r\n        var ctx = document.getElementById('myChart').getContext(\"2d\");\r\n        let colorTable = this.buildColorTable(g1Top.length);\r\n        this.gradeChart = new Chart(ctx, {\r\n            type: 'doughnut',\r\n            data: {\r\n                labels: gradeData.map((gradeData) => gradeData.name + \": \" + gradeData.value),\r\n                datasets: [{\r\n                    data: gradeData.map((gradeData) => gradeData.value),\r\n                    backgroundColor: [\r\n                        'rgba(0, 204, 0, 1)',\r\n                        'rgba(255, 128, 0, 1)',\r\n                        'rgba(255, 0, 255, 1)',\r\n                        'rgba(0, 0, 255, 1)',\r\n                    ],\r\n                    borderColor: [\r\n                        'rgba(0, 204, 0, 1)',\r\n                        'rgba(255, 128, 0, 1)',\r\n                        'rgba(255, 0, 255, 1)',\r\n                        'rgba(0, 0, 255, 1)',    \r\n                    ],\r\n                    borderWidth: 1\r\n                }]\r\n            },\r\n            options: {\r\n                onClick: (e) => {\r\n                    this.clickChart(e);\r\n                },\r\n                maintainAspectRatio: false,\r\n                responsive: true,\r\n                legend: {\r\n                    position: 'right',\r\n\r\n                    labels: {\r\n                        padding: 10,\r\n                        boxWidth: 12\r\n                    }\r\n                }\r\n            }\r\n        });\r\n\r\n        var ctx = document.getElementById(\"grade1\").getContext('2d');\r\n        var g1Chart = new Chart(ctx, {\r\n            type: 'doughnut',\r\n            data: {\r\n                labels: g1Top.map((g1Top) => g1Top.name + \": \" + g1Top.value),\r\n                datasets: [{\r\n                    data: g1Top.map((g1Top) => g1Top.value),\r\n                    backgroundColor: this.buildColorTable(g1Top.length),\r\n                    borderColor: this.buildColorTable(g1Top.length),\r\n                    borderWidth: 1\r\n                }]\r\n            },\r\n            options: {\r\n                title: {\r\n                    display: true,\r\n                    position: 'top',\r\n                    text: 'Priority 1',\r\n                },\r\n                maintainAspectRatio: false,\r\n                responsive: true,\r\n                legend: {\r\n                    position: 'right',\r\n                    fullWidth: false,\r\n                    labels: {\r\n                        padding: 10,\r\n                        boxWidth: 12\r\n                    }\r\n                }\r\n            }\r\n        });\r\n\r\n        var ctx = document.getElementById(\"grade2\").getContext('2d');\r\n        var g2Chart = new Chart(ctx, {\r\n            type: 'doughnut',\r\n        data: {\r\n            labels: g2Top.map((g2Top) => g2Top.name + \": \" + g2Top.value),\r\n            datasets: [{\r\n                data: g2Top.map((g2Top) => g2Top.value),\r\n                backgroundColor: this.buildColorTable(g2Top.length),\r\n                borderColor: this.buildColorTable(g2Top.length),\r\n                borderWidth: 1\r\n            }]\r\n        },\r\n        options: {\r\n            title: {\r\n                display: true,\r\n                text: 'Priority 2',\r\n            },\r\n            maintainAspectRatio: false,\r\n            responsive: true,\r\n            legend: {\r\n                position: 'right',\r\n                labels: {\r\n                    padding: 10,\r\n                    boxWidth: 12\r\n                }\r\n            }\r\n        }\r\n        });\r\n\r\n        var ctx = document.getElementById(\"grade3\").getContext('2d');\r\n            var g3Chart = new Chart(ctx, {\r\n                type: 'doughnut',\r\n            data: {\r\n                labels: g3Top.map((g3Top) => g3Top.name + \": \" + g3Top.value),\r\n                datasets: [{\r\n                    data: g3Top.map((g3Top) => g3Top.value),\r\n                    backgroundColor: this.buildColorTable(g3Top.length),\r\n                    borderColor: this.buildColorTable(g3Top.length),\r\n                    borderWidth: 1\r\n                }]\r\n            },\r\n            options: {\r\n                title: {\r\n                    display: true,\r\n                    text: 'Priority 3',\r\n                    padding: 5,\r\n                },\r\n                maintainAspectRatio: false,\r\n                responsive: true,\r\n                legend: {\r\n                    position: 'right',\r\n                    labels: {\r\n                        padding: 10,\r\n                        boxWidth: 12\r\n                    }\r\n                }\r\n            }\r\n            });\r\n           \r\n        }\r\n            \r\n            \r\n        \r\n    }\r\n    render() {\r\n        const { login } = this.props.location\r\n        const { user } = this.props.location\r\n        const { data } = this.props.location\r\n        this.user = user;\r\n        this.login = login;\r\n        this.data = data;\r\n        \r\n    return (\r\n        <div> \r\n            <Navbar bg=\"light\" expand=\"lg\"> \r\n        \r\n          <Navbar.Brand href=\"#home\">\r\n          <img\r\n              src=\"logo.png\"\r\n              width=\"122\"\r\n              height=\"58\"\r\n              className=\"d-inline-block align-top\"\r\n              alt=\"logo\"\r\n            />\r\n          </Navbar.Brand>\r\n          <Nav> \r\n            <Link className=\"dropdownlink\" to={'/'} style={{ textDecoration: 'none' }}>Home</Link>\r\n            </Nav>\r\n            <CustomNav title={this.user}></CustomNav>\r\n            </Navbar>\r\n            \r\n            <div className=\"chartParent\">\r\n            <div className = \"gradediv\">\r\n                    <canvas className=\"gradeChart\" id=\"myChart\"></canvas>  \r\n                </div>\r\n                <div className = \"g1div\">\r\n                    <canvas className=\"g1Chart\" id=\"grade1\"></canvas>  \r\n                </div>\r\n                <div className = \"g2div\">\r\n                    <canvas className=\"g2Chart\" id=\"grade2\"></canvas>  \r\n                </div>\r\n                <div className = \"g3div\">\r\n                    <canvas className=\"g3Chart\" id=\"grade3\"></canvas>  \r\n                </div>\r\n                \r\n            </div>    \r\n      </div> \r\n    );\r\n    }\r\n}\r\nexport default Report;\r\n  \r\n","S:\\website\\photoviewer\\client\\src\\App.js",["101","102","103","104","105","106","107"],"S:\\website\\photoviewer\\client\\src\\CustomNav.js",[],"S:\\website\\photoviewer\\client\\src\\DynamicDropdown.js",[],"S:\\website\\photoviewer\\client\\src\\CustomModal.js",[],"S:\\website\\photoviewer\\client\\src\\Drawer.js",[],"S:\\website\\photoviewer\\client\\src\\ToolsMenu.js",[],"S:\\website\\photoviewer\\client\\src\\VideoCard.js",[],"S:\\website\\photoviewer\\client\\src\\PhotoModal.js",[],"S:\\website\\photoviewer\\client\\src\\ArchivePhotoModal.js",[],"S:\\website\\photoviewer\\client\\src\\GLEngine.js",["108","109","110","111","112","113","114","115","116"],"import Vector2D from './Vector2D';\r\nimport {LatLongToPixelXY, translateMatrix, scaleMatrix} from  './util.js';\r\nimport L from 'leaflet';\r\nimport './L.CanvasOverlay';\r\n\r\nconst DUPLICATE_OFFSET = 0.00002;\r\n\r\nexport default class GLEngine {\r\n \r\n    constructor(leaflet) {\r\n        this.leafletMap = leaflet;\r\n        this.mouseClick = null;\r\n        this.gl = null;\r\n        this.glPoints = [];\r\n        this.glLines = [];\r\n        this.latlngs = [];\r\n        this.intializeGL();    \r\n    }\r\n\r\n  intializeGL() {\r\n    if (this.gl == null) {\r\n      this.glLayer = L.canvasOverlay()\r\n      .addTo(this.leafletMap);\r\n      this.canvas = this.glLayer.canvas();\r\n      this.glLayer.canvas.width = this.canvas.width;\r\n      this.glLayer.canvas.height = this.canvas.height;\r\n    }\r\n    this.gl = this.canvas.getContext('webgl2', { antialias: false }, {preserveDrawingBuffer: false}); \r\n    if (!this.gl) {\r\n        this.gl = this.canvas.getContext('webgl', { antialias: false }, {preserveDrawingBuffer: false});\r\n        //console.log(\"Cannot load webgl2.0 using webgl instead\");\r\n    }  \r\n    if (!this.gl) {\r\n      this.gl = this.canvas.getContext('experimental-webgl', { antialias: false }, {preserveDrawingBuffer: false});\r\n      console.log(\"Cannot load webgl1.0 using experimental-webgl instead\");\r\n    } \r\n    if (!this.gl) {\r\n      alert(\"Error: Failed to load webgl.\\n\" + \"Your browser may not support webgl - this web app will not work correctly.\\n\" + \"Please use a modern web browser.\")\r\n    } \r\n    this.glLayer.delegate(this); \r\n    this.addEventListeners();\r\n    }\r\n\r\n  /**\r\n * adds various event listeners to the canvas\r\n */\r\n  addEventListeners() {\r\n    this.canvas.addEventListener(\"webglcontextlost\", function(event) {\r\n    event.preventDefault();\r\n    console.log(\"CRASH--recovering GL\")\r\n    }, false);\r\n    this.canvas.addEventListener(\"webglcontextrestored\", function(event) {\r\n        this.intializeGL();\r\n    }, false);\r\n  }\r\n\r\n  \r\n  setAppDelegate(delegate) {\r\n      this.appDelegate = delegate;\r\n  }\r\n\r\n  /**\r\n   * Checks points to see if a point is selected and colors red\r\n   * else returns vertices\r\n   * Also returns verts coloured by index number to establish which index user clicked\r\n   * @param {the point data} data \r\n   * @returns vertices data as Float32 array\r\n   */\r\n  reColorPoints(verts) {\r\n    //console.log(verts)\r\n    if (this.mouseClick === null) {\r\n      if (this.appDelegate.state.selectedIndex === null) {\r\n        return verts;\r\n      } else {\r\n        for (let i = 0; i < verts.length; i += 9) {\r\n          if (verts[i + 8] === this.appDelegate.state.selectedIndex) {\r\n            verts[i + 4] = 1.0;\r\n            verts[i + 5] = 0;\r\n            verts[i + 6] = 0;\r\n            verts[i + 7] = 1.0;\r\n          }\r\n        }\r\n      }   \r\n    } else {\r\n      for (let i = 0; i < verts.length; i += 9) {\r\n        let index = verts[i + 8];\r\n        //console.log(index);\r\n        //calculates r,g,b color from index\r\n        let r = ((index & 0x000000FF) >>  0) / 255;\r\n        let g = ((index & 0x0000FF00) >>  8) / 255;\r\n        let b = ((index & 0x00FF0000) >> 16) / 255;\r\n        verts[i + 4] = r;\r\n        verts[i + 5] = g;\r\n        verts[i + 6] = b;\r\n        verts[i + 7] = 1.0; //alpha\r\n      }\r\n    }\r\n    return verts;\r\n  }\r\n\r\n  redraw(points, lines) {\r\n    //console.log(lines);\r\n    console.log(\"redrawing..\");\r\n    this.glPoints = points;\r\n    const numPoints = points.length;\r\n    this.glLines = lines;\r\n    this.glLayer.drawing(drawingOnCanvas); \r\n    let pixelsToWebGLMatrix = new Float32Array(16);\r\n    this.mapMatrix = new Float32Array(16);  \r\n        // -- WebGl setup\r\n    let vertexShader = this.gl.createShader(this.gl.VERTEX_SHADER);\r\n    this.gl.shaderSource(vertexShader, document.getElementById('vshader').text);\r\n    this.gl.compileShader(vertexShader);\r\n    let fragmentShader = this.gl.createShader(this.gl.FRAGMENT_SHADER);\r\n    //let length = this.state.activeLayers.length - 1;\r\n    this.gl.shaderSource(fragmentShader, document.getElementById('fshader-square').text);\r\n    this.gl.compileShader(fragmentShader);\r\n    // link shaders to create our program\r\n    let program = this.gl.createProgram();\r\n    this.gl.attachShader(program, vertexShader);\r\n    this.gl.attachShader(program, fragmentShader);\r\n    this.gl.linkProgram(program);\r\n    this.gl.useProgram(program);\r\n    this.gl.blendFunc(this.gl.SRC_ALPHA, this.gl.ONE_MINUS_SRC_ALPHA); //<---?\r\n    this.gl.enable(this.gl.BLEND);\r\n    // look up the locations for the inputs to our shaders.\r\n    let u_matLoc = this.gl.getUniformLocation(program, \"u_matrix\");\r\n    let u_eyepos = this.gl.getUniformLocation(program, \"u_eyepos\");\r\n    let u_eyeposLow = this.gl.getUniformLocation(program, \"u_eyepos_low\");\r\n    let colorLoc = this.gl.getAttribLocation(program, \"a_color\");\r\n    let vertLoc = this.gl.getAttribLocation(program, \"a_vertex\");\r\n    let vertLocLow = this.gl.getAttribLocation(program, \"a_vertex_low\");\r\n    //let colorLoc = this.gl.getAttribLocation(program, \"a_color\");\r\n    //let vertLoc = this.gl.getAttribLocation(program, \"a_vertex\");\r\n    this.gl.aPointSize = this.gl.getAttribLocation(program, \"a_pointSize\");\r\n    pixelsToWebGLMatrix.set([2 / this.canvas.width, 0, 0, 0, 0, -2 / this.canvas.height, 0, 0, 0, 0, 0, 0, -1, 1, 0, 1]);\r\n    // Set the matrix to some that makes 1 unit 1 pixel.\r\n    this.gl.viewport(0, 0, this.canvas.width, this.canvas.height);\r\n    this.gl.uniformMatrix4fv(u_matLoc, false, pixelsToWebGLMatrix); \r\n    let thickness = 0.00001;\r\n    //console.log(lines.vertices)\r\n    let verts = lines.vertices.concat(points);\r\n    let vertBuffer = this.gl.createBuffer();\r\n    verts = this.reColorPoints(verts);\r\n    let numLines = lines.vertices.length / 9;\r\n    let vertArray = new Float32Array(verts);\r\n    let fsize = vertArray.BYTES_PER_ELEMENT;\r\n    this.gl.bindBuffer(this.gl.ARRAY_BUFFER, vertBuffer);\r\n    this.gl.bufferData(this.gl.ARRAY_BUFFER, vertArray, this.gl.STATIC_DRAW);\r\n    this.gl.vertexAttribPointer(vertLoc, 2, this.gl.FLOAT, false, fsize * 9, 0);\r\n    this.gl.enableVertexAttribArray(vertLoc);\r\n    this.gl.vertexAttribPointer(vertLocLow, 2, this.gl.FLOAT, false, fsize * 9, fsize * 2);\r\n    this.gl.enableVertexAttribArray(vertLocLow);\r\n    // -- offset for color buffer\r\n    this.gl.vertexAttribPointer(colorLoc, 4, this.gl.FLOAT, false, fsize * 9, fsize * 4);\r\n    this.gl.enableVertexAttribArray(colorLoc);\r\n    this.glLayer.redraw();\r\n\r\n    function drawingOnCanvas(canvasOverlay, params) {\r\n      if (this.delegate.gl == null)  {\r\n        return;\r\n      }\r\n      this.delegate.gl.clearColor(0, 0, 0, 0);\r\n      this.delegate.gl.clear(this.delegate.gl.COLOR_BUFFER_BIT);\r\n      pixelsToWebGLMatrix.set([2 / params.canvas.width, 0, 0, 0, 0, -2 / params.canvas.height, 0, 0, 0, 0, 0, 0, -1, 1, 0, 1]);\r\n      this.delegate.gl.viewport(0, 0, params.canvas.width, params.canvas.height);\r\n      let pointSize = Math.max(this._map.getZoom() - 7.0, 1.0);\r\n      this.delegate.gl.vertexAttrib1f(this.delegate.gl.aPointSize, pointSize);\r\n      // -- set base matrix to translate canvas pixel coordinates -> webgl coordinates\r\n      this.delegate.mapMatrix.set(pixelsToWebGLMatrix);\r\n      let bounds = this._map.getBounds();\r\n      let topLeft = new L.LatLng(bounds.getNorth(), bounds.getWest());\r\n      let pixelOffset = LatLongToPixelXY(topLeft.lat, topLeft.lng);\r\n      // -- Scale to current zoom\r\n      var scale = Math.pow(2, this._map.getZoom());\r\n      scaleMatrix(this.delegate.mapMatrix, scale, scale);\r\n      //translateMatrix(this.delegate.mapMatrix, -offset.x, -offset.y);\r\n      let u_matLoc = this.delegate.gl.getUniformLocation(program, \"u_matrix\");\r\n      // -- attach matrix value to 'mapMatrix' uniform in shader\r\n      this.delegate.gl.uniformMatrix4fv(u_matLoc, false, this.delegate.mapMatrix);\r\n      this.delegate.gl.uniform3f(u_eyepos, pixelOffset.x, pixelOffset.y, 0.0);\r\n      let offsetLow = {x: pixelOffset.x - Math.fround(pixelOffset.x), y: pixelOffset.y - Math.fround(pixelOffset.y)}\r\n      this.delegate.gl.uniform3f(u_eyeposLow, offsetLow.x, offsetLow.y, 0.0);\r\n      let offset = 0;\r\n      // for (var i = 0; i < numLines; i++) {\r\n      // let count = lines.lengths[i];\r\n      //   this.delegate.gl.drawArrays(this.delegate.gl.TRIANGLES, offset, count * 3); \r\n      //   offset += 9; \r\n      // }\r\n\r\n      //draw thin lines\r\n      for (var i = 0; i < lines.lengths.length; i += 1) {             \r\n        let count = lines.lengths[i];\r\n        this.delegate.gl.drawArrays(this.delegate.gl.LINE_STRIP, offset, count);\r\n        offset += count;\r\n      } \r\n      this.delegate.gl.drawArrays(this.delegate.gl.POINTS, offset, numPoints);\r\n      if (this.delegate.mouseClick !== null) {      \r\n        let pixel = new Uint8Array(4);\r\n        this.delegate.gl.readPixels(this.delegate.mouseClick.originalEvent.layerX, \r\n        this.delegate.canvas.height - this.delegate.mouseClick.originalEvent.layerY, 1, 1, this.delegate.gl.RGBA, this.delegate.gl.UNSIGNED_BYTE, pixel);\r\n        console.log(pixel)\r\n        let index = pixel[0] + (pixel[1] * 256) + (pixel[2] * 256 * 256);\r\n        this.delegate.mouseClick = null;\r\n        this.delegate.appDelegate.setIndex(index);   \r\n        this._redraw();\r\n      }\r\n    }\r\n  }\r\n\r\n  /**\r\n * Loops through json objects and extracts fault information\r\n * Builds object containing fault information and calls redraw\r\n * @param {JSON array of fault objects received from db} data \r\n * @param {String type of data ie. road or footpath} type\r\n */\r\n  drawThinLines(data, type, priorities, pointCount) {\r\n    let faults = [];\r\n    let glPoints = [];\r\n    let lengths = [];\r\n    let alpha = 1.0; \r\n    for (let i = 0; i < data.length; i++) {\r\n      //if (data[i].id === \"MDC_RD_0521_1742\") {\r\n        const linestring = JSON.parse(data[i].st_asgeojson);\r\n        const latlng = L.latLng(linestring.coordinates[0][1], linestring.coordinates[0][0]);\r\n        const priority = data[i].priority;\r\n        \r\n        if (linestring !== null) {\r\n          ++pointCount;   \r\n          let line = linestring.coordinates;\r\n          lengths.push(line.length);\r\n          for (let j = 0; j < line.length; j++) {\r\n            const point = line[j];\r\n            const lng = point[0];\r\n            const lat = point[1];\r\n            this.latlngs.push(L.latLng(lat, lng));\r\n            const pixel = LatLongToPixelXY(point[1], point[0]);\r\n            const pixelLow = { x: pixel.x - Math.fround(pixel.x), y: pixel.y - Math.fround(pixel.y) };\r\n            const pixelHigh = {x: pixel.x, y: pixel.y};\r\n            if (type === \"road\") {\r\n              if (data[i].status === \"active\") { //road\r\n                if(priority === priorities.high) {\r\n                  glPoints.push(pixelHigh.x, pixelHigh.y, pixelLow.x, pixelLow.y, 1.0, 0, 1.0, alpha, pointCount); \r\n                } else if (priority === priorities.med) {\r\n                  glPoints.push(pixelHigh.x, pixelHigh.y, pixelLow.x, pixelLow.y, 1.0, 0.5, 0, alpha, pointCount);\r\n                } else if (priority === priorities.low) {\r\n                  glPoints.push(pixelHigh.x, pixelHigh.y, pixelLow.x, pixelLow.y, 0, 0.8, 0, alpha, pointCount);\r\n                } else if (priority === 99) {\r\n                  glPoints.push(pixelHigh.x, pixelHigh.y, pixelLow.x, pixelLow.y, 0, 0, 1, alpha, pointCount);\r\n                } else {\r\n                  glPoints.push(pixelHigh.x, pixelHigh.y, pixelLow.x, pixelLow.y, 0, 0.8, 0, alpha, pointCount);\r\n                }\r\n              } else {\r\n                glPoints.push(pixelHigh.x, pixelHigh.y, pixelLow.x, pixelLow.y, 0.5, 0.5, 0.5, 0.8, alpha, pointCount);\r\n              } \r\n            } else { //footpath\r\n\r\n            }\r\n          }\r\n          \r\n        }\r\n        let fault = this.createFaultObject(data[i], type, latlng)\r\n        faults.push(fault);\r\n    }\r\n    return {vertices: glPoints, lengths: lengths, faults: faults};\r\n  }\r\n\r\n  drawLines(data, type, priorities) {\r\n    const thickness = 0.00001;\r\n    let glPoints = [];\r\n    let lengths = [];\r\n    let alpha = 1.0; \r\n    for (let i = 0; i < data.length; i++) {\r\n      const linestring = JSON.parse(data[i].st_asgeojson);\r\n      const priority = data[i].priority;\r\n      if (linestring !== null) {  \r\n        let line = linestring.coordinates;\r\n        if (line.length < 2) {\r\n          console.log(line[i]);\r\n          continue;\r\n        } else if (line.length === 2 ) {\r\n          lengths.push(line.length);\r\n          const point0 = line[0];\r\n          const point1 = line[1];\r\n          const pixel0 = LatLongToPixelXY(point0[1], point0[0]);\r\n          const pixel1 = LatLongToPixelXY(point1[1], point1[0]);\r\n          const p0 = new Vector2D(pixel0.x, pixel0.y);\r\n          const p1 = new Vector2D(pixel1.x, pixel1.y);\r\n          const pixelLine = Vector2D.subtract(p1, p0);\r\n          const normal = new Vector2D(-pixelLine.y, pixelLine.x)\r\n          const normalized = normal.normalize();\r\n          const vertex1 = Vector2D.subtract(p0, Vector2D.multiply(normalized, thickness));\r\n          const vertex2 = Vector2D.add(p0,  Vector2D.multiply(normalized, thickness));\r\n          const vertex3 = Vector2D.subtract(p1, Vector2D.multiply(normalized, thickness));\r\n          const vertex4 =  Vector2D.add(p1, Vector2D.multiply(normalized, thickness));\r\n          const l = Vector2D.subtract(vertex1, vertex2).length(); //<thickness of line\r\n          //console.log(\"thickness \" + l);\r\n          const vertex1Low = { x: vertex1.x - Math.fround(vertex1.x), y: vertex1.y - Math.fround(vertex1.y) };\r\n          const vertex1High = {x: vertex1.x, y: vertex1.y};\r\n          const vertex2Low = { x: vertex2.x - Math.fround(vertex2.x), y: vertex2.y - Math.fround(vertex2.y) };\r\n          const vertex2High = {x: vertex2.x, y: vertex2.y};\r\n          const vertex3Low = { x: vertex3.x - Math.fround(vertex3.x), y: vertex3.y - Math.fround(vertex3.y) };\r\n          const vertex3High = {x: vertex3.x, y: vertex3.y};\r\n          const vertex4Low = { x: vertex4.x - Math.fround(vertex4.x), y: vertex4.y - Math.fround(vertex4.y) };\r\n          const vertex4High = {x: vertex4.x, y: vertex4.y};\r\n          \r\n          glPoints.push(vertex1High.x, vertex1High.y, vertex1Low.x, vertex1Low.y, 1.0, 0, 1.0, alpha, i + 1);\r\n          glPoints.push(vertex2High.x, vertex2High.y, vertex2Low.x, vertex2Low.y, 1.0, 0, 1.0, alpha, i + 1);\r\n          glPoints.push(vertex3High.x, vertex3High.y, vertex3Low.x, vertex3Low.y, 1.0, 0, 1.0, alpha, i + 1);\r\n          glPoints.push(vertex2High.x, vertex2High.y, vertex2Low.x, vertex2Low.y, 1.0, 0, 1.0, alpha, i + 1);\r\n          glPoints.push(vertex3High.x, vertex3High.y, vertex3Low.x, vertex3Low.y, 1.0, 0, 1.0, alpha, i + 1);\r\n          glPoints.push(vertex4High.x, vertex4High.y, vertex4Low.x, vertex4Low.y, 1.0, 0, 1.0, alpha, i + 1);  \r\n          //6 * 9 = 54 elements per two point line\r\n        } else {\r\n          \r\n        }\r\n        \r\n      }      \r\n    }\r\n    return {vertices: glPoints, lengths: lengths}\r\n  }\r\n\r\n  buildPoints(data, type, priorities) {\r\n    let obj = {}; //return\r\n    let faults = []; \r\n    let latlngs = [];\r\n    let points = []; //TODO change to Float32Array to make selection faster\r\n    let count = 0;\r\n    let pointSet = new Set();\r\n    for (let i = 0; i < data.length; i++) { //start at one index 0 will be black\r\n      const position = JSON.parse(data[i].st_asgeojson);\r\n      const lng = position.coordinates[0];\r\n      const lat = position.coordinates[1];\r\n      const latlng = L.latLng(lat, lng);\r\n      latlngs.push(L.latLng(lat, lng));\r\n      this.addToSet(pointSet, L.latLng(lat, lng));\r\n      const pixel = LatLongToPixelXY(lat, lng);\r\n      const pixelLow = { x: pixel.x - Math.fround(pixel.x), y: pixel.y - Math.fround(pixel.y) };\r\n      const pixelHigh = {x: pixel.x, y: pixel.y};\r\n      let alpha = 1.0;\r\n      if (type === \"road\") {\r\n        // let bucket = data[i].inspection;\r\n        // if (bucket != null) {\r\n        //   let suffix = this.state.amazon.substring(this.state.amazon.length - 8,  this.state.amazon.length - 1);\r\n        //   if (bucket !== suffix) {\r\n        //     alpha = 0.5;\r\n        //   }\r\n        // }\r\n        if (data[i].status === \"active\") { //road\r\n          if(data[i].priority === priorities.high) {\r\n            points.push(pixelHigh.x, pixelHigh.y, pixelLow.x, pixelLow.y, 1.0, 0, 1.0, alpha, ++count);\r\n          } else if (data[i].priority === priorities.med) {\r\n            points.push(pixelHigh.x, pixelHigh.y, pixelLow.x, pixelLow.y, 1.0, 0.5, 0, alpha, ++count);\r\n          } else if (data[i].grade === priorities.low) {\r\n            if (this.state.login === \"chbdc\") {\r\n              points.push(pixelHigh.x, pixelHigh.y, pixelLow.x, pixelLow.y, 1, 1, 0, 1, ++count);\r\n            } else {\r\n              points.push(pixelHigh.x, pixelHigh.y, pixelLow.x, pixelLow.y, 0, 0.8, 0, 1, ++count);\r\n            }        \r\n          } else if (data[i].priority === 99) {\r\n            points.push(pixelHigh.x, pixelHigh.y, pixelLow.x, pixelLow.y, 0, 0, 1, alpha, ++count);\r\n          } else {\r\n            points.push(pixelHigh.x, pixelHigh.y, pixelLow.x, pixelLow.y, 0, 0.8, 0, alpha, ++count);\r\n          }\r\n        } else {\r\n          points.push(pixelHigh.x, pixelHigh.y, pixelLow.x, pixelLow.y, 0.5, 0.5, 0.5, 0.8, ++count);\r\n        }\r\n      } else {\r\n        if (data[i].status === \"active\") { //footpath\r\n          if(data[i].grade === priorities.high) {\r\n            points.push(pixelHigh.x, pixelHigh.y, pixelLow.x, pixelLow.y, 1.0, 0, 1.0, 1, ++count);\r\n          } else if (data[i].grade === priorities.med) {\r\n            points.push(pixelHigh.x, pixelHigh.y, pixelLow.x, pixelLow.y, 1.0, 0.5, 0, 1, ++count);\r\n          } else if (data[i].grade === priorities.low) {\r\n            if (this.state.login === \"chbdc\") {\r\n              points.push(pixelHigh.x, pixelHigh.y, pixelLow.x, pixelLow.y, 1, 1, 0, 1, ++count);\r\n            } else {\r\n              points.push(pixelHigh.x, pixelHigh.y, pixelLow.x, pixelLow.y, 0, 0.8, 0, 1, ++count);\r\n            }\r\n            \r\n          } else {\r\n            points.push(pixelHigh.x, pixelHigh.y, pixelLow.x, pixelLow.y, 0, 0.8, 0.8, 1, ++count);\r\n          }\r\n        } else {\r\n          points.push(pixelHigh.x, pixelHigh.y, pixelLow.x, pixelLow.y, 0.5, 0.5, 0.5, 0.8, ++count);\r\n        }  \r\n      }  \r\n      let fault = this.createFaultObject(data[i], type, latlng)\r\n      faults.push(fault);         \r\n    }\r\n    return {\r\n      faults: faults,\r\n      points: points,\r\n      count: count\r\n    }\r\n  }\r\n\r\n  buildVertices(lines, points, thickness) {\r\n    for (let i = 0; i < lines.length; i += 1) {\r\n      let red = 0;\r\n      let green = 0;\r\n      let blue = 1;  \r\n      for (let j = 0; j < lines[i].segment.length; j += 1) {\r\n        if (lines[i].segment.length < 2) {\r\n          console.log(lines[i]);\r\n          continue;\r\n        }\r\n        if(lines[i].segment.length === 2 ) {\r\n          const pixel0 = {x: lines[i].segment[0].x, y: lines[i].segment[0].y};   \r\n          const pixel1 = {x: lines[i].segment[1].x, y: lines[i].segment[1].y};\r\n          if (pixel0.x === pixel1.x || pixel0.y === pixel1.y) {\r\n            continue;\r\n          }\r\n          let p0 = new Vector2D(pixel0.x, pixel0.y);\r\n          let p1 = new Vector2D(pixel1.x, pixel1.y);\r\n          let line = Vector2D.subtract(p1, p0);\r\n          let normal = new Vector2D(-line.y, line.x)\r\n          let normalized = normal.normalize();\r\n          let a = Vector2D.subtract(p0, Vector2D.multiply(normalized, thickness));\r\n          let b = Vector2D.add(p0,  Vector2D.multiply(normalized, thickness));\r\n          let c = Vector2D.subtract(p1, Vector2D.multiply(normalized, thickness));\r\n          let d =  Vector2D.add(p1, Vector2D.multiply(normalized, thickness));\r\n          let l = Vector2D.subtract(a, b).length();\r\n          if (l > thickness * 2.1) {\r\n            console.log(l);\r\n          }\r\n          points.push(a.x, a.y, red, green, blue, 1, 1);\r\n          points.push(b.x, b.y, red, green, blue, 1, 1);\r\n          points.push(c.x, c.y, red, green, blue, 1, 1);\r\n          points.push(c.x, c.y, red, green, blue, 1, 1); \r\n          points.push(d.x, d.y, red, green, blue, 1, 1);\r\n          points.push(b.x, b.y, red, green, blue, 1, 1);\r\n          continue;\r\n        } else {\r\n          if (j === 0) {\r\n            const pixel0 = {x: lines[i].segment[j].x, y: lines[i].segment[j].y};\r\n            const pixel1 = {x: lines[i].segment[j + 1].x, y: lines[i].segment[j + 1].y};\r\n            const pixel2 = {x: lines[i].segment[j + 2].x, y: lines[i].segment[j + 2].y};\r\n            let p0 = new Vector2D(pixel0.x, pixel0.y);\r\n            let p1 = new Vector2D(pixel1.x, pixel1.y);\r\n            let p2 = new Vector2D(pixel2.x, pixel2.y);\r\n    \r\n            let line = Vector2D.subtract(p1, p0);\r\n            let normal = new Vector2D(-line.y, line.x)\r\n            let normalized = normal.normalize();\r\n            let a = Vector2D.subtract(p0, Vector2D.multiply(normalized,thickness));\r\n            let b = Vector2D.add(p0, Vector2D.multiply(normalized,thickness));\r\n  \r\n            let miter = this.getMiter(p0, p1, p2, thickness);\r\n            if (miter.x === 0 && miter.y === 0) {\r\n              continue;\r\n            }\r\n            let c = Vector2D.subtract(p1, miter);\r\n            let d = Vector2D.add(p1, miter);  \r\n            let l = Vector2D.subtract(a, b).length();\r\n            points.push(a.x, a.y, red, green, blue, 1, 1);\r\n            points.push(b.x, b.y, red, green, blue, 1, 1);\r\n            points.push(c.x, c.y, red, green, blue, 1, 1);\r\n            points.push(c.x, c.y, red, green, blue, 1, 1); \r\n            points.push(d.x, d.y, red, green, blue, 1, 1);\r\n            points.push(b.x, b.y, red, green, blue, 1, 1);\r\n            } else if (j === lines[i].segment.length - 2) {\r\n            const pixel0 = {x: lines[i].segment[j -1].x, y: lines[i].segment[j -1].y};\r\n            const pixel1 = {x: lines[i].segment[j].x, y: lines[i].segment[j].y};\r\n            const pixel2 = {x: lines[i].segment[j + 1].x, y: lines[i].segment[j + 1].y};\r\n            let p0 = new Vector2D(pixel0.x, pixel0.y);\r\n            let p1 = new Vector2D(pixel1.x, pixel1.y);\r\n            let p2 = new Vector2D(pixel2.x, pixel2.y);\r\n            let miter1 = this.getMiter(p0, p1, p2, thickness);\r\n            if (miter1.x === 0 && miter1.y === 0) {\r\n              break;\r\n            }\r\n            let a = Vector2D.add(p1, miter1);\r\n            let b = Vector2D.subtract(p1,  miter1);\r\n            let line = Vector2D.subtract(p2, p1);\r\n            let normal = new Vector2D(-line.y, line.x)\r\n            let normalized = normal.normalize();\r\n            let c = Vector2D.subtract(p2, Vector2D.multiply(normalized,thickness));\r\n            let d = Vector2D.add(p2, Vector2D.multiply(normalized,thickness));\r\n            let l = Vector2D.subtract(c, d).length();\r\n            if (l > thickness * 2.1) {\r\n              console.log(l);\r\n            }\r\n            points.push(a.x, a.y, red, green, blue, 1, 1);\r\n            points.push(b.x, b.y, red, green, blue, 1, 1);\r\n            points.push(c.x, c.y, red, green, blue, 1, 1);\r\n            points.push(c.x, c.y, red, green, blue, 1, 1); \r\n            points.push(d.x, d.y, red, green, blue, 1, 1);\r\n            points.push(a.x, a.y, red, green, blue, 1, 1);\r\n            break;  \r\n            } else {\r\n            const pixel0 = {x: lines[i].segment[j -1].x, y: lines[i].segment[j -1].y};\r\n            const pixel1 = {x: lines[i].segment[j].x, y: lines[i].segment[j].y};\r\n            const pixel2 = {x: lines[i].segment[j + 1].x, y: lines[i].segment[j + 1].y};\r\n            const pixel3 = {x: lines[i].segment[j + 2].x, y: lines[i].segment[j + 2].y};\r\n            let p0 = new Vector2D(pixel0.x, pixel0.y);\r\n            let p1 = new Vector2D(pixel1.x, pixel1.y);\r\n            let p2 = new Vector2D(pixel2.x, pixel2.y);\r\n            let p3 = new Vector2D(pixel3.x, pixel3.y);\r\n            //meter calc\r\n            let miter1 = this.getMiter(p0, p1, p2, thickness);\r\n            if (miter1.x === 0 && miter1.y === 0) {\r\n              continue;\r\n            }\r\n            p1 = new Vector2D(pixel1.x, pixel1.y);\r\n            p2 = new Vector2D(pixel2.x, pixel2.y);\r\n            p3 = new Vector2D(pixel3.x, pixel3.y);\r\n            let miter2 = this.getMiter(p1, p2, p3, thickness);\r\n            if (miter2.x === 0 && miter2.y === 0) {\r\n              continue;\r\n            }\r\n            let a = Vector2D.add(p1, miter1);\r\n            let b = Vector2D.subtract(p1,  miter1);\r\n            let c = Vector2D.add(p2, miter2);\r\n            let d = Vector2D.subtract(p2,  miter2);\r\n            points.push(a.x, a.y, red, green, blue, 1, 1);\r\n            points.push(b.x, b.y, red, green, blue, 1, 1);\r\n            points.push(c.x, c.y, red, green, blue, 1, 1);\r\n            points.push(c.x, c.y, red, green, blue, 1, 1);\r\n            points.push(d.x, d.y, red, green, blue, 1, 1);\r\n            points.push(b.x, b.y, red, green, blue, 1, 1);\r\n          }\r\n        }\r\n      }\r\n    }\r\n    return points;\r\n    }\r\n  \r\n    getMiter(p0, p1, p2, thickness) {\r\n      let p2p1 = Vector2D.subtract(p2, p1);\r\n      let p1p0 = Vector2D.subtract(p1, p0);\r\n      let y = p2p1.y * -1;\r\n      let normal = new Vector2D(y, p2p1.x);\r\n      let normalized = normal.normalize();\r\n      p2p1.normalize();\r\n      p1p0.normalize();\r\n      p2p1 = Vector2D.subtract(p2, p1);\r\n      let tangent = Vector2D.add(p2p1, p1p0);    \r\n      let nTangent = tangent.normalize();\r\n      y = nTangent.y * -1;\r\n      let miter = new Vector2D(-nTangent.y, nTangent.x);\r\n      let length = thickness / Vector2D.dot(miter, normalized);\r\n      if (length > thickness * 1.5 || length < thickness * 0.5) {\r\n        return new Vector2D(0, 0);\r\n      }\r\n      let l = miter.multiply(length);\r\n      return new Vector2D(l.x, l.y);  \r\n    } \r\n\r\n    createFaultObject(data, type, latlng) {\r\n      let id = data.id.split('_');\r\n      let obj = {};\r\n      if (type === \"footpath\") {   \r\n        obj = {\r\n          type: type,\r\n          id: id[id.length - 1],\r\n          roadid: data.roadid,\r\n          footpathid: data.footpathid,\r\n          roadname: data.roadname,        \r\n          location: data.location,\r\n          asset:  data.asset,\r\n          fpsurface: data.type,\r\n          fault: data.fault,\r\n          cause: data.cause,\r\n          width: data.width,\r\n          length: data.length,\r\n          grade: data.grade,\r\n          photo: data.photoid,\r\n          datetime: data.faulttime,\r\n          latlng: latlng,\r\n          status: data.status,\r\n          datefixed: data.datefixed\r\n        };\r\n      } else {\r\n        obj = {\r\n          type: type,\r\n          id: id[id.length - 1],\r\n          roadid: data.roadid,\r\n          carriage: data.carriage,\r\n          inspection: data.inspection,\r\n          location: data.location,\r\n          class: data.class,\r\n          fault: data.fault,\r\n          repair: data.repair,\r\n          comment: data.comment,\r\n          width: data.width,\r\n          length: data.length,\r\n          priority: data.priority,\r\n          photo: data.photoid,\r\n          datetime: data.faulttime,\r\n          latlng: latlng,\r\n          status: data.status,\r\n          datefixed: data.datefixed\r\n        };\r\n      }\r\n      return obj;\r\n    }\r\n\r\n    addToSet(set, latlng) {\r\n      if (set.has(latlng.lat.toString() + latlng.lng.toString())) {\r\n        let randomLat = Math.random() >= 0.5;\r\n        let randomPlus = Math.random() >= 0.5;\r\n        if (randomLat) {\r\n          if (randomPlus) {\r\n            latlng.lat += DUPLICATE_OFFSET;\r\n          } else {\r\n            latlng.lat -= DUPLICATE_OFFSET;\r\n          }\r\n        } else {\r\n          if (randomPlus) {\r\n            latlng.lng += DUPLICATE_OFFSET;\r\n          } else {\r\n            latlng.lng -= DUPLICATE_OFFSET;\r\n          }\r\n        }\r\n        set.add(latlng.lat.toString() + latlng.lng.toString());\r\n      } else {\r\n        set.add(latlng.lat.toString() + latlng.lng.toString());\r\n      }\r\n    }\r\n\r\n    minMaxLineSize() {\r\n      const [minLineSize, maxLineSize] = this.gl.getParameter(this.gl.ALIASED_LINE_WIDTH_RANGE);\r\n      return [minLineSize, maxLineSize];\r\n    }\r\n\r\n    minMaxPointSize() {\r\n      const [minPointSize, maxPointSize] = this.gl.getParameter(this.gl.ALIASED_POINT_SIZE_RANGE);\r\n      return [minPointSize, maxPointSize];\r\n    }\r\n};","S:\\website\\photoviewer\\client\\src\\util.js",["117"],"const EARTH_RADIUS = 6378137.0 //metres\r\nconst TILE_SIZE = 256\r\nconst EARTH_EQUATOR = 40075016.68557849\r\n\r\nconst RDP = (l, eps) => {\r\n    const last = l.length - 1;\r\n    const p1 = l[0];\r\n    const p2 = l[last];\r\n    const x21 = p2.x - p1.x;\r\n    const y21 = p2.y - p1.y;\r\n   \r\n    const [dMax, x] = l.slice(1, last)\r\n        .map(p => Math.abs(y21 * p.x - x21 * p.y + p2.x * p1.y - p2.y * p1.x))\r\n        .reduce((p, c, i) => {\r\n          const v = Math.max(p[0], c);\r\n          return [v, v === p[0] ? p[1] : i + 1];\r\n        }, [-1, 0]);\r\n   \r\n    if (dMax > eps) {\r\n      return [...RDP(l.slice(0, x + 1), eps), ...RDP(l.slice(x), eps).slice(1)];\r\n    }\r\n    return [l[0], l[last]]\r\n  };\r\n\r\n  let LatLongToPixelXY = (latitude, longitude) => {\r\n    let pi_180 = Math.PI / 180.0;\r\n    let pi_4 = Math.PI * 4;\r\n    let sinLatitude = Math.sin(latitude * pi_180);\r\n    let pixelX = ((longitude + 180) / 360) * TILE_SIZE;\r\n    let pixelY = (0.5 - Math.log((1 + sinLatitude) / (1 - sinLatitude)) / (pi_4)) * TILE_SIZE;\r\n    let pixel = { x: pixelX, y: pixelY };\r\n    return pixel;\r\n  };\r\n\r\n  let ShpericalLatLongToPixelXY = (latitude, longitude) => {\r\n    let equator = 40075016.68557849;\r\n    let pixelX = (longitude + (equator / 2.0)) / (equator / TILE_SIZE);\r\n    let pixelY = (latitude - (equator / 2.0)) / (equator / TILE_SIZE);\r\n    let pixel = { x: pixelX, y: pixelY };\r\n    return pixel;\r\n  };\r\n\r\n  /**\r\n   * Calculates distance on earth surface\r\n   */\r\n  let calcGCDistance = (distance) => {\r\n    return distance * EARTH_RADIUS * (Math.PI /180);\r\n  }\r\n\r\n  function sleep(milliseconds) {\r\n    const date = Date.now();\r\n    let currentDate = null;\r\n    do {\r\n      currentDate = Date.now();\r\n    } while (currentDate - date < milliseconds);\r\n  }\r\n\r\n  function translateMatrix(matrix, tx, ty) {\r\n    // translation is in last column of matrix\r\n    matrix[12] += matrix[0] * tx + matrix[4] * ty;\r\n    matrix[13] += matrix[1] * tx + matrix[5] * ty;\r\n    matrix[14] += matrix[2] * tx + matrix[6] * ty;\r\n    matrix[15] += matrix[3] * tx + matrix[7] * ty;\r\n  }\r\n  \r\n  function scaleMatrix(matrix, scaleX, scaleY) {\r\n    // scaling x and y, which is just scaling first two columns of matrix\r\n    matrix[0] *= scaleX;\r\n    matrix[1] *= scaleX;\r\n    matrix[2] *= scaleX;\r\n    matrix[3] *= scaleX;\r\n    matrix[4] *= scaleY;\r\n    matrix[5] *= scaleY;\r\n    matrix[6] *= scaleY;\r\n    matrix[7] *= scaleY;\r\n  }\r\n  \r\n  // Returns a random integer from 0 to range - 1.\r\n  function randomInt(range) {\r\n    return Math.floor(Math.random() * range);\r\n  }\r\n\r\n  /**\r\n   * \r\n   * @param {the number to pad} n \r\n   * @param {the amount of pading} width \r\n   * @param {digit to pad out number with (default '0'} z \r\n   * @return {the padded number (string)}\r\n   */\r\n  function pad(n, width, z) {\r\n    z = z || '0';\r\n    n = n + '';\r\n    return n.length >= width ? n : new Array(width - n.length + 1).join(z) + n;\r\n    }\r\n\r\n  /**\r\n   * returns a random hex color\r\n   */\r\n  function getColor() {\r\n    return '#' +  Math.random().toString(16).substr(-6);\r\n  }\r\n\r\n  function formatDate(date) {\r\n    let tokens = date.split(\"_\");\r\n    let month = getMonth(tokens[1]);\r\n    return month + \" \" + tokens[0];\r\n  }\r\n\r\n  function getMonth(month) {\r\n    switch(month) {\r\n      case \"01\":\r\n        return \"January\";\r\n      case \"02\":\r\n        return \"Feburary\";\r\n      case \"03\":\r\n        return \"March\";\r\n      case \"04\":\r\n        return \"April\";\r\n      case \"05\":\r\n        return \"May\";\r\n      case \"06\":\r\n        return \"June\";\r\n      case \"07\":\r\n        return \"July\";\r\n      case \"08\":\r\n        return \"August\";\r\n      case \"09\":\r\n        return \"September\";\r\n      case \"10\":\r\n        return \"October\";\r\n      case \"11\":\r\n        return \"November\";\r\n      case \"12\":\r\n        return \"December\";\r\n      default:\r\n        return month\r\n    }\r\n  }\r\n\r\n  export {RDP, LatLongToPixelXY, ShpericalLatLongToPixelXY, translateMatrix, scaleMatrix, randomInt, pad, getColor, getMonth, formatDate, calcGCDistance, sleep}","S:\\website\\photoviewer\\client\\src\\PositionControl.js",[],"S:\\website\\photoviewer\\client\\src\\MediaPlayerControl.js",[],"S:\\website\\photoviewer\\client\\src\\L.CanvasOverlay.js",[],"S:\\website\\photoviewer\\client\\src\\Vector2D.js",[],{"ruleId":"118","replacedBy":"119"},{"ruleId":"120","replacedBy":"121"},{"ruleId":"122","severity":1,"message":"123","line":143,"column":17,"nodeType":"124","messageId":"125","endLine":143,"endColumn":20},{"ruleId":"122","severity":1,"message":"123","line":174,"column":17,"nodeType":"124","messageId":"125","endLine":174,"endColumn":20},{"ruleId":"122","severity":1,"message":"123","line":203,"column":17,"nodeType":"124","messageId":"125","endLine":203,"endColumn":20},{"ruleId":"122","severity":1,"message":"123","line":299,"column":13,"nodeType":"124","messageId":"125","endLine":299,"endColumn":16},{"ruleId":"126","severity":1,"message":"127","line":300,"column":13,"nodeType":"124","messageId":"128","endLine":300,"endColumn":23},{"ruleId":"122","severity":1,"message":"123","line":339,"column":13,"nodeType":"124","messageId":"125","endLine":339,"endColumn":16},{"ruleId":"126","severity":1,"message":"129","line":340,"column":13,"nodeType":"124","messageId":"128","endLine":340,"endColumn":20},{"ruleId":"122","severity":1,"message":"123","line":370,"column":13,"nodeType":"124","messageId":"125","endLine":370,"endColumn":16},{"ruleId":"122","severity":1,"message":"130","line":371,"column":13,"nodeType":"124","messageId":"125","endLine":371,"endColumn":20},{"ruleId":"126","severity":1,"message":"131","line":371,"column":13,"nodeType":"124","messageId":"128","endLine":371,"endColumn":20},{"ruleId":"122","severity":1,"message":"123","line":399,"column":13,"nodeType":"124","messageId":"125","endLine":399,"endColumn":16},{"ruleId":"122","severity":1,"message":"132","line":400,"column":17,"nodeType":"124","messageId":"125","endLine":400,"endColumn":24},{"ruleId":"126","severity":1,"message":"133","line":400,"column":17,"nodeType":"124","messageId":"128","endLine":400,"endColumn":24},{"ruleId":"126","severity":1,"message":"134","line":4,"column":107,"nodeType":"124","messageId":"128","endLine":4,"endColumn":124},{"ruleId":"126","severity":1,"message":"135","line":4,"column":126,"nodeType":"124","messageId":"128","endLine":4,"endColumn":138},{"ruleId":"126","severity":1,"message":"136","line":16,"column":8,"nodeType":"124","messageId":"128","endLine":16,"endColumn":17},{"ruleId":"126","severity":1,"message":"137","line":21,"column":9,"nodeType":"124","messageId":"128","endLine":21,"endColumn":25},{"ruleId":"126","severity":1,"message":"138","line":21,"column":27,"nodeType":"124","messageId":"128","endLine":21,"endColumn":52},{"ruleId":"126","severity":1,"message":"139","line":21,"column":54,"nodeType":"124","messageId":"128","endLine":21,"endColumn":69},{"ruleId":"126","severity":1,"message":"140","line":21,"column":71,"nodeType":"124","messageId":"128","endLine":21,"endColumn":82},{"ruleId":"126","severity":1,"message":"139","line":2,"column":27,"nodeType":"124","messageId":"128","endLine":2,"endColumn":42},{"ruleId":"141","severity":1,"message":"142","line":38,"column":46,"nodeType":"143","messageId":"144","endLine":38,"endColumn":47},{"ruleId":"141","severity":1,"message":"142","line":38,"column":127,"nodeType":"143","messageId":"144","endLine":38,"endColumn":128},{"ruleId":"126","severity":1,"message":"145","line":140,"column":9,"nodeType":"124","messageId":"128","endLine":140,"endColumn":18},{"ruleId":"126","severity":1,"message":"146","line":145,"column":9,"nodeType":"124","messageId":"128","endLine":145,"endColumn":17},{"ruleId":"126","severity":1,"message":"147","line":275,"column":13,"nodeType":"124","messageId":"128","endLine":275,"endColumn":21},{"ruleId":"126","severity":1,"message":"148","line":296,"column":17,"nodeType":"124","messageId":"128","endLine":296,"endColumn":18},{"ruleId":"126","severity":1,"message":"149","line":324,"column":9,"nodeType":"124","messageId":"128","endLine":324,"endColumn":12},{"ruleId":"126","severity":1,"message":"148","line":455,"column":17,"nodeType":"124","messageId":"128","endLine":455,"endColumn":18},{"ruleId":"126","severity":1,"message":"150","line":3,"column":7,"nodeType":"124","messageId":"128","endLine":3,"endColumn":20},"no-native-reassign",["151"],"no-negated-in-lhs",["152"],"no-redeclare","'ctx' is already defined.","Identifier","redeclared","no-unused-vars","'colorTable' is assigned a value but never used.","unusedVar","'g1Chart' is assigned a value but never used.","'g2Chart' is already defined.","'g2Chart' is assigned a value but never used.","'g3Chart' is already defined.","'g3Chart' is assigned a value but never used.","'ToggleButtonGroup' is defined but never used.","'ToggleButton' is defined but never used.","'ToolsMenu' is defined but never used.","'LatLongToPixelXY' is defined but never used.","'ShpericalLatLongToPixelXY' is defined but never used.","'translateMatrix' is defined but never used.","'scaleMatrix' is defined but never used.","no-useless-concat","Unexpected string concatenation of literals.","BinaryExpression","unexpectedConcat","'thickness' is assigned a value but never used.","'numLines' is assigned a value but never used.","'priority' is assigned a value but never used.","'l' is assigned a value but never used.","'obj' is assigned a value but never used.","'EARTH_EQUATOR' is assigned a value but never used.","no-global-assign","no-unsafe-negation"]